## QEUR21_MZPROT2:　「カメラ目線」でメイズを歩く

## ～　2D学習による「カメラ目線」はかなり合理的・・・　～

QEU:FOUNDER ; “それでは、ひきつづき準備段階として3Dメイズでのマニュアル運転をやりましょう。ただし、相当に複雑になるんだ。これが・・・。プログラムの中で使われる**「座標系」が3種類になる**んです。”

![imageRL6-3-1](https://reinforce.github.io/images/imageRL6-3-1.jpg) 

D先生 ; “面倒だが、しょうがないですね。”

QEU:FOUNDER ; “今回は途中段階の「デモプログラム」にすぎないんで、このプログラムで**「カメラ目線の出来栄え」**をみてみましょう。それでは・・・、ドン！！”

```python
# ----------------
# メイズ(MAZE)ゲームの強化学習システム
# step3 : RayCastと強化学習の併用
# PROGRAM NAME : demonstration_cntlVisual_RayCast_Maze.py
# step3 : 今回はマニュアル操作版です
# step3 : カメラ画像の方向は、2DMazeの学習結果で決めています。
# 注意： キーの使い方は本来は回転・前進後退ですが、今回は方向キーによる上下左右移動に改造しています
#      最終的には8方向に改造します
# ----------------
import numpy as np
import pandas as pd
import math, copy, random, time, sys
from IPython.display import clear_output
# ----------------
import torch
import torch.nn.functional
import torch.utils.data
# ----------------
import pygame
#os.environ['SDL_VIDEO_WINDOW_POS'] = "%d, %d" %(20, 20)
# ---------------- 
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = (16, 10)

# =================================================
# Game board difinition 
# =================================================
foldername  = "./MAZE_test/"

# =================================================
# difinition of STATE CALCULATION function
# =================================================
# タイムライン用minRTメトリックスを計算する
def timeline_minRT(a_row, a_col, iCnt_turn):
    len_route = len(mx_route)
    if iCnt_turn <= len_route - 1:
        pos_rt  = mx_route[iCnt_turn]
    else:
        pos_rt  = mx_route[len_route - 1]
    # -----
    tlEuc   = (a_row - pos_rt[0])**2 + (a_col - pos_rt[1])**2
    dist_tlminRT = np.sqrt(tlEuc)
        
    return round(dist_tlminRT,5)

# -------
# 空間用minRTメトリックスを計算する
def space_minRT(pos_route, a_row, a_col):
    len_route = len(pos_route)
    arr_sminRT = []
    for i in range(len_route):
        pos_rt  = pos_route[i]
        sqEuc   = (a_row - pos_rt[0])**2 + (a_col - pos_rt[1])**2
        distEuc = np.sqrt(sqEuc)
        arr_sminRT.append(round(distEuc,5))   
    dist_sminRT = np.min(arr_sminRT)
        
    return dist_sminRT

# -------
# 状態の表記を変更(XY座標へ)、空間用minRTメトリックスつき
def calc_address(a_row, a_col, mx_lm, iCnt_turn):

    add_state = np.zeros(2)
    for i in range(2):
        pos_lm  = mx_lm[i]
        sqEuc   = (a_row - pos_lm[0])**2 + (a_col - pos_lm[1])**2
        distEuc = np.sqrt(sqEuc)
        add_state[i] = round(distEuc,5)
             
    # 空間用minRTメトリックスを計算する
    # Aルート(標準)
    dist_sminRTA = space_minRT(mx_route, a_row, a_col)
    dist_sminRTA = round(dist_sminRTA,5)
    # Bルート(標準との差異分)
    dist_sminRTB = space_minRT(mx_routeB, a_row, a_col)
    dist_sminRTB = round(dist_sminRTB,5) - dist_sminRTA
    # Cルート(標準との差異分)
    dist_sminRTC = space_minRT(mx_routeC, a_row, a_col)
    dist_sminRTC = round(dist_sminRTC,5) - dist_sminRTA
    # タイムライン用minRTメトリックスを計算する
    dist_tlminRT = timeline_minRT(a_row, a_col, iCnt_turn)

    # ------------------------------------------------
    # 距離とりまとめリストを生成する
    arr_RTDists = np.zeros(5)
    arr_RTDists[0] = add_state[0] + add_state[1]     # Total距離
    arr_RTDists[1] = dist_sminRTA    # 空間minRT距離
    arr_RTDists[2] = dist_tlminRT    # タイムラインminRT距離
    arr_RTDists[3] = dist_sminRTB    # 空間用minRT距離(B)
    arr_RTDists[4] = dist_sminRTC    # 空間用minRT距離(C)

    # STATEを生成する
    state = np.hstack([[a_row, a_col], add_state, [dist_sminRTA, dist_sminRTB, dist_sminRTC]])
    
    return state, arr_RTDists

# ----------
# Maze Class
class Maze(object):
    def __init__(self, size=27, blocks_rate=0.1):
        self.size = size if size > 3 else 27
        self.blocks = int((size ** 2) * blocks_rate) 
        self.s_list = []
        self.maze_list = []
        self.e_list = []

    def create_mid_lines(self, k):
        if k == 0: self.maze_list.append(self.s_list)
        elif k == self.size - 1: self.maze_list.append(self.e_list)
        else:
            tmp_list = []
            for l in range(0,self.size):
                if l == 0: tmp_list.extend("#")
                elif l == self.size-1: tmp_list.extend("#")
                else:
                    a = random.randint(-1, 0)
                    tmp_list.extend([a])
            self.maze_list.append(tmp_list)

    def insert_blocks(self, k, s_r, e_r):
        b_y = random.randint(1, self.size-2)
        b_x = random.randint(1, self.size-2)
        if [b_y, b_x] == [1, s_r] or [b_y, b_x] == [self.size - 2, e_r]: k = k-1
        else: self.maze_list[b_y][b_x] = "#"
            
    def generate_maze(self): 
        s_r = random.randint(1, int((self.size / 2)) - 1)
        for i in range(0, self.size):
            if i == s_r: self.s_list.extend("S")
            else: self.s_list.extend("#")
        start_point = [0, s_r]

        e_r = random.randint(int((self.size / 2)) + 1, self.size - 2)
        for j in range(0, self.size):
            if j == e_r: self.e_list.extend([50])
            else: self.e_list.extend("#")
        goal_point = [self.size - 1, e_r]

        for k in range(0, self.size):
            self.create_mid_lines(k)
        
        for k in range(self.blocks):
            self.insert_blocks(k, s_r, e_r)

        return self.maze_list, start_point, goal_point

    # ------------------------------------------------
    # 盤面のCSVファイルを読み込み表示する
    def read_boardfile(self):
        # CSVファイルの読み込み
        code_csvout = "maze_board27.csv"       # file name
        file_readcsv = foldername + code_csvout   # standard(training) file name  
        df = pd.read_csv(file_readcsv)
        #max_play = len(df)
        # print("データ量 max_play",max_play)
        # print(df)
        # ------------------------------------------------
        # 選択項目の読み込み
        maze = df.loc[:, "0":"26"].values.tolist()
        start_point, goal_point = [0,0], [0,0]
        for i in range(size):
            for j in range(size):
                if maze[i][j] == 'S':
                    start_point = [i, j]
                if maze[i][j] == '5000':
                    goal_point  = [i, j]
        # -----
        self.maze_list   = maze
        self.start_point = start_point
        self.goal_point  = goal_point
        #print("goal_point", goal_point)
        #print("----- mx_maze(read_boardfile) -----")
        #print(maze)

        return self.maze_list, start_point, goal_point

    # ------------------------------------------------
    # コマの最短ルートのCSVファイルを読み込み表示する（標準Aルート）
    def read_chessfile(self):
        # CSVファイルの読み込み
        code_csvout = "chess_route27.csv"       # file name
        file_readcsv = foldername + code_csvout   # standard(training) file name  
        df = pd.read_csv(file_readcsv)
        #max_play = len(df)
        # print("データ量 max_play",max_play)
        # print(df)
        # ------------------------------------------------
        # 選択項目の読み込み
        mx_route    = df.loc[:, "row":"col"].values.tolist()
        ref_action  = df.loc[:, "action"].values.tolist()
        #print("ref_action: ", ref_action)
        #print("----- route -----")
        #print(route)

        return mx_route, ref_action

    # ------------------------------------------------
    # コマの最短ルートのCSVファイルを読み込み表示する（限界BCルート）
    def read_chessfileBC(self, code_csvout):

        # CSVファイルの読み込み
        file_readcsv = foldername + code_csvout   # standard(training) file name  
        df = pd.read_csv(file_readcsv)
        #max_play = len(df)
        # print("データ量 max_play",max_play)
        # print(df)
        # ------------------------------------------------
        # 選択項目の読み込み
        mx_route    = df.loc[:, "row":"col"].values.tolist()

        return mx_route

# ----------
# Maze functions
class Field(object):
    def __init__(self, maze, start_point, goal_point):
        # ----------------
        # 次の行動(ACTION-８方向)に進む
        # action number / row / col / 方向/ ベクトル(変則ONEHOT)
        # 0 / -1 / 0  / 上上(up-up) / [-1, 0]
        # 1 / -1 / -1  / 上左(up-left) / [-1, -1]
        # 2 / 0 / -1  / 左左(left-left) / [0, -1]
        # 3 / +1 / -1  / 左下(down-left) / [+1, -1]
        # 4 / +1 / 0  / 下下(down-down) / [+1, 0]
        # 5 / +1 / +1  / 下右(down-right) / [+1, +1]
        # 6 / 0  / +1 / 右右(right-right) / [0, +1]
        # 7 / -1  / +1 / 上右(up-right) / [-1, +1]
        # ----------------
        self.maze = maze
        self.start_point = start_point
        self.goal_point  = goal_point
        self.movable_vec = [[-1, 0],[-1, -1],[0, -1],[1, -1],[1, 0],[1, 1],[0, 1],[-1, 1]]

    def display(self, point=None):
        field_data = copy.deepcopy(self.maze)
        if not point is None:
                y, x = point
                field_data[y][x] = "@@"
        else:
                point = ""
        print("================")
        for line in field_data:
                print ("\t" + "%3s " * len(line) % tuple(line))
        print("================")

    def all_display(self, mx_route):
        field_data = copy.deepcopy(self.maze)
        for i in range(len(mx_route)):
            point = mx_route[i]
            y, x = point[0], point[1]
            field_data[y][x] = "@@"
        print("================")
        for line in field_data:
                print ("\t" + "%3s " * len(line) % tuple(line))
        print("================")

    def get_actions(self, state):
        movables = []
        if state == self.start_point:
            y = state[0] + 1
            x = state[1]
            a = [[y, x]]
            return a
        else:
            for v in self.movable_vec:
                y = state[0] + v[0]
                x = state[1] + v[1]
                if not(0 < x < len(self.maze) and
                       0 <= y <= len(self.maze) - 1 and
                       self.maze[y][x] != "#" and
                       self.maze[y][x] != "S"):
                    continue
                movables.append([y,x])
            if len(movables) != 0:
                return movables
            else:
                return None

    # ------------------------------------------------
    # 次のコマの「決定」位置と報酬、ゲームフラグを決める
    # 新概念：マスク「#」位置に着くと、スタート地点に戻る
    def get_val(self, action_chess, state_chess, movables):
        yPos = action_chess[0]
        xPos = action_chess[1]
        # ----------------
        if action_chess == self.start_point:
            nxt_state = action_chess
            return nxt_state, 0, False, 0
        elif self.maze[yPos][xPos] == "#":
            #print("movables: ", movables)
            if len(movables) > 0:
                nxt_state = random.choice(movables)
            else:
                nxt_state = self.start_point
            v = -0.1        # -10
            return nxt_state, v, False, 1
        else:
            nxt_state = action_chess
            v = float(self.maze[yPos][xPos])
            if action_chess == self.goal_point: 
                return nxt_state, v, True, 0
            else: 
                return nxt_state, v, False, 0

# ----------
# Initialize and Generate a maze
size, barriar_rate = 27, 0.1
maze_1 = Maze(size, barriar_rate)
# init_maze : カリキュラム学習用に改造
init_maze, start_point, goal_point = maze_1.read_boardfile()
print("start_point: {}, goal_point: {}".format(start_point, goal_point))
# インスタンスの生成
maze_field = Field(init_maze, start_point, goal_point)
# ボード表示(初期表示)
maze_field.display()
# ----------
# 最短ルートを読み込み(Aルート)
mx_route, ref_action = maze_1.read_chessfile()
# ルートを表示する
maze_field.all_display(mx_route)
# ----------
# コマの最短ルートのCSVファイルを読み込み表示する（限界BCルート）
# Bルート
mx_routeB = maze_1.read_chessfileBC("chess_route27B.csv")
# Cルート
mx_routeC = maze_1.read_chessfileBC("chess_route27C.csv")
#print("--- mx_routeC ---")
#print(mx_routeC)

# ----------
# 入力用:Pytorchモデルのファイル名
comment_input_model = "initial"
code_input_model = "model_2DMaze_DQNER_{0}.pt".format(comment_input_model)  # モデルの指定
file_input_model = foldername + code_input_model  # ファイルパス名の生成

#=================================================
# Deep Learning Model class            
#=================================================
# PyTorchのDLの定義
class Net(torch.nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = torch.nn.Linear(dim_input, 128)
        self.fc1.weight.data.normal_(0, 0.1)
        self.fc2 = torch.nn.Linear(128, 128)
        self.fc2.weight.data.normal_(0, 0.1)
        self.fc3 = torch.nn.Linear(128, 128)
        self.fc3.weight.data.normal_(0, 0.1)
        self.fc4 = torch.nn.Linear(128, dim_output)
        self.fc4.weight.data.normal_(0, 0.1)
        
    def forward(self, x):
        x = torch.nn.functional.relu(self.fc1(x))
        x = torch.nn.functional.relu(self.fc2(x))
        x = torch.nn.functional.relu(self.fc3(x))
        x = self.fc4(x)
        return x

# =======================================
# Solving the maze in Deep Q-learning
class DQN_Solver:

    def __init__(self, state_size, action_size):

        # 共通変数
        self.state_size  = state_size # list size of state
        self.action_size = action_size # list size of action
        self.learning_rate = 0.002 # learning rate of neural network
        # ------------------------------------------------
        # crate instance for input
        self.eval_net = Net()           # Netを利用して２つのニューラルネットをつくる
        # ------------------------------------------------
        # Save and load the model via state_dict
        self.eval_net.load_state_dict(torch.load(file_input_model))
        # ------------------------------------------------
        # set validaiton mode
        self.eval_net.eval()
        # ------------------------------------------------
        # set training parameters
        #self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=self.learning_rate)
        #self.criterion = torch.nn.MSELoss()

    # choosing action depending on epsilon
    def choose_action(self, state, movables):

        # ----------------
        # 次の行動(ACTION-８方向)に進む
        # action number / row / col / 方向/ ベクトル
        # 0 / -1 / 0  / 上上(up-up) / [-1, 0]
        # 1 / -1 / -1  / 上左(up-left) / [-1, -1]
        # 2 / 0 / -1  / 左左(left-left) / [0, -1]
        # 3 / +1 / -1  / 左下(down-left) / [+1, -1]
        # 4 / +1 / 0  / 下下(down-down) / [+1, 0]
        # 5 / +1 / +1  / 下右(down-right) / [+1, +1]
        # 6 / 0  / +1 / 右右(right-right) / [0, +1]
        # 7 / -1  / +1 / 上右(up-right) / [-1, +1]
        # ----------------
        action_chess = [0,0]
        acType, Qvalue, iCnt = "machine", -0.001, 0
        for a_order in movables:

            # 変則ONE-HOT化
            diff_row = a_order[0] - state[0]
            diff_col = a_order[1] - state[1]
            # ----------------
            # 状態(STATE)行動(ACTION)ベクトルを生成する
            np_action = np.hstack([state, [diff_row, diff_col]])
            if iCnt == 0:
                mx_input   = [np_action]  # 状態(S)行動(A)マトリックス
            else:
                mx_input   = np.concatenate([mx_input, [np_action]], axis=0)     # 状態(S)行動(A)マトリックス
            iCnt = iCnt + 1
        # print("----- mx_input -----")
        # print(mx_input)
        # ------------------------------------------------
        # generate new 'x'
        x_input_tensor = torch.tensor(mx_input).float()
        # predict 'y'
        with torch.no_grad():
            y_pred_tensor = self.eval_net(x_input_tensor)
        # convert tensor to numpy
        y_pred       = y_pred_tensor.data.numpy().flatten()
        Qvalue       = np.max(y_pred)
        temp_order   = np.argmax(y_pred)
        action_chess = movables[temp_order]
        #print("state:{0}, y_pred:{1}, temp_order:{2}, action_chess:{3}".format(state, y_pred, temp_order, action_chess))

        return acType, action_chess, Qvalue


# =================================================
# difinition of functions
# =================================================
# Hyper Parameters
state_size, action_size = 7, 2
dim_input, dim_output = state_size + action_size, 1
dql_solver  = DQN_Solver(state_size, action_size)
# -------------------------
# pygame初期化
pygame.init()
# -------------------------
TURN    = math.pi/4
STEP    = 15
RES     = 320
VANG    = math.pi/6
PLAYERDISTANCE = (RES/2)/math.tan(VANG)
FOV     = []
i       = -VANG
while (i < VANG):
    FOV.append(i)
    i+=(VANG*2)/RES
WIDE, HIGH = 64, 128
# -------------------------
pygame.display.set_caption("Raycast Maze")
CLOCK = pygame.time.Clock()

## ############################## WALLS ##############################
SPRITEBLOCK = pygame.image.load("walls.png")
ROWWLL = [None] * 64
COLWLL = [None] * 64
ROWBGN = [None] * 64
COLBGN = [None] * 64
ROWEND = [None] * 64
COLEND = [None] * 64
for i in range(64):
    ROWWLL[i] = pygame.Surface((1,64))
    COLWLL[i] = pygame.Surface((1,64))
    ROWBGN[i] = pygame.Surface((1,64))
    COLBGN[i] = pygame.Surface((1,64))
    ROWEND[i] = pygame.Surface((1,64))
    COLEND[i] = pygame.Surface((1,64))
    ROWWLL[i].blit(SPRITEBLOCK, [0,0], ( 0+i,  0, 1, 64))
    COLWLL[i].blit(SPRITEBLOCK, [0,0], (64+i,  0, 1, 64))
    ROWBGN[i].blit(SPRITEBLOCK, [0,0], ( 0+i, 64, 1, 64))
    COLBGN[i].blit(SPRITEBLOCK, [0,0], (64+i, 64, 1, 64))
    ROWEND[i].blit(SPRITEBLOCK, [0,0], ( 0+i,128, 1, 64))
    COLEND[i].blit(SPRITEBLOCK, [0,0], (64+i,128, 1, 64))
## ############################## WALLS ##############################

## #########################################################################################
## ############################# START : PRIM'S MAZE ALGORITHM #############################
## #########################################################################################

def removeWalls(x, y, maze, frontier, rows, cols):
    N,E,S,W,IN,FRONTIER = 1,2,4,8,16,32
    ins = []

    #add to possible wall removal if IS IN MAZE and DOES HAVE WALL
    if (x > 0) and ((maze[x-1][y] & IN) == IN) and ((maze[x][y] & W) == W):
        ins.append([x-1,y,E,W])
    if (x < cols-1) and ((maze[x+1][y] & IN) == IN) and ((maze[x][y] & E) == E):
        ins.append([x+1,y,W,E])
    if (y > 0) and ((maze[x][y-1] & IN) == IN) and ((maze[x][y] & N) == N):
        ins.append([x,y-1,S,N])
    if (y < rows-1) and ((maze[x][y+1] & IN) == IN) and ((maze[x][y] & S) == S):
        ins.append([x,y+1,N,S])

    #if there is a wall to remove - Select Random Room and Remove Walls adjoining cells
    if (len(ins) > 0):
        deWall = random.choice(ins)
        thisX = x
        thisY = y
        thisW = deWall[3]
        thatX = deWall[0]
        thatY = deWall[1]
        thatW = deWall[2]
        maze[thisX][thisY] = maze[thisX][thisY] & ~thisW
        maze[thatX][thatY] = maze[thatX][thatY] & ~thatW

def addToMaze(x, y, maze, frontier, rows, cols):
    N,E,S,W,IN,FRONTIER = 1,2,4,8,16,32

    maze[x][y] = maze[x][y] & ~FRONTIER #remove from frontier
    maze[x][y] = maze[x][y] | IN #add to maze
    removeWalls(x, y, maze, frontier, rows, cols) #remove walls
    makeFrontier(x,y,maze,frontier, rows, cols) #make new frontier

def makeFrontier(x,y,maze,frontier, rows, cols):
    N,E,S,W,IN,FRONTIER = 1,2,4,8,16,32

    if (x > 0) and ((maze[x-1][y] & IN) != IN):
        if (maze[x-1][y] & FRONTIER) != FRONTIER:
            maze[x-1][y] = maze[x-1][y] | FRONTIER
            frontier.append([x-1,y])
    if (x < cols-1) and ((maze[x+1][y] & IN) != IN):
        if (maze[x+1][y] & FRONTIER) != FRONTIER:
            maze[x+1][y] = maze[x+1][y] | FRONTIER
            frontier.append([x+1,y])
    if (y > 0) and ((maze[x][y-1] & IN) != IN):
        if (maze[x][y-1] & FRONTIER) != FRONTIER:
            maze[x][y-1] = maze[x][y-1] | FRONTIER
            frontier.append([x,y-1])
    if (y < rows-1) and ((maze[x][y+1] & IN) != IN):
        if (maze[x][y+1] & FRONTIER) != FRONTIER:
            maze[x][y+1] = maze[x][y+1] | FRONTIER
            frontier.append([x,y+1])

def makeMaze(rows,cols):
    N,E,S,W,IN,FRONTIER = 1,2,4,8,16,32

    MAZEROWS = rows
    MAZECOLS = cols
    frontier = []
    maze = [[(N|E|S|W) for y in range(MAZEROWS)] for x in range(MAZECOLS)] #create maze with all walls

    addToMaze(0, 0, maze, frontier, MAZEROWS, MAZECOLS)
    while (len(frontier) > 0):
        random.shuffle(frontier)
        tmp = frontier.pop()
        addToMaze(tmp[0], tmp[1], maze, frontier, MAZEROWS, MAZECOLS)

    return maze

## #######################################################################################
## ############################# END : PRIM'S MAZE ALGORITHM #############################
## #######################################################################################

## ############################# START : TURN MAZE INTO GAMEBOARD #############################
def gameBoard(maze):
    N,E,S,W,IN,FRONTIER = 1,2,4,8,16,32

    PATHWIDTH = 2

    MCOLS = len(maze)
    MROWS = len(maze[0])

    COLP = (MCOLS*PATHWIDTH)+1
    ROWP = (MROWS*PATHWIDTH)+1
    game = [[0 for y in range(ROWP)] for x in range(COLP)] #create empty gameboard

    for y in range(MROWS):
        for x in range(MCOLS):
            if (maze[x][y] & N):
                for i in range(PATHWIDTH+1):
                    game[(x*PATHWIDTH)+i][y*PATHWIDTH] = 1
            if (maze[x][y] & W):
                for i in range(PATHWIDTH+1):
                    game[x*PATHWIDTH][(y*PATHWIDTH)+i] = 1

    for y in range(ROWP):
        game[COLP-1][y] = 1
    for x in range(COLP):
        game[x][ROWP-1] = 1

    return game

## ############################# END : TURN MAZE INTO GAMEBOARD #############################
def makeBackground(ROWS,COLS):
    BACKGROUND = pygame.Surface((COLS*WIDE,ROWS*WIDE))
    #Whole self.BACKGROUND
    BACKGROUND.fill((128,128,128))
    #Just the Ceiling
    pygame.draw.rect(BACKGROUND, (192,192,192), [0,0, COLS*WIDE, ROWS*WIDE/2], 0)
    return BACKGROUND

def makeMap(gameboard):
    COLS = len(gameboard)
    ROWS = len(gameboard[0])
    MAP = pygame.Surface((COLS,ROWS))
    MAP.fill((192,192,192))
    for y in range(ROWS):
        for x in range(COLS):
            if(int(gameboard[y][x]) == 1):
                pygame.draw.rect(MAP, (0,0,0), [x,y, 1, 1], 0)
    return MAP

## #######################################################################################
## ################################# START : RAY-CASTING #################################
## #######################################################################################
def canGo(x,y,gameboard):
    COLS = len(gameboard)
    ROWS = len(gameboard[0])

    dx = math.floor(x/WIDE)
    dy = math.floor(y/WIDE)
    if (dx > 0) and (dx < COLS) and (dy > 0) and (dy < ROWS):
        if (int(gameboard[dy][dx]) == 0):
            return True
    return False

def castRay(raydir,posX,posY,playdir,gameboard):
    COLS = len(gameboard)
    ROWS = len(gameboard[0])

    rays = []
    rise = math.sin(raydir)
    run = math.cos(raydir)
    if (abs(run) > 0.001):
        slope = rise/run
    else:
        slope = 10000

    if (raydir > (3*math.pi/2)):
        colRange = [math.ceil(posX/WIDE),COLS, 1] #low to high
        rowRange = [math.floor(posY/WIDE),0,-1]   #high to low
        colHit = 0
        rowHit = -1
    elif (raydir > (math.pi)):
        colRange = [math.floor(posX/WIDE),0,-1]   #high to low
        rowRange = [math.floor(posY/WIDE),0,-1]   #high to low
        colHit = -1
        rowHit = -1
    elif (raydir > (math.pi/2)):
        colRange = [math.floor(posX/WIDE),0,-1]   #high to low
        rowRange = [math.ceil(posY/WIDE),ROWS, 1] #low to high
        colHit = -1
        rowHit = 0
    else:
        colRange = [math.ceil(posX/WIDE),COLS, 1] #low to high
        rowRange = [math.ceil(posY/WIDE),ROWS, 1] #low to high
        colHit = 0
        rowHit = 0

    hitR = False
    if (abs(slope) > 0.0001):    
        for y in range(rowRange[0],rowRange[1],rowRange[2]):
            if (hitR): break
            rowY = y * WIDE
            rowX = (rowY - posY + (slope * posX)) / slope
            if (rowX >= 0) and (rowX < ROWS*WIDE):
                hitY = math.floor(rowY/WIDE)+rowHit
                hitX = math.floor(rowX/WIDE)
                if (int(gameboard[hitY][hitX]) == 1):
                    distance = math.sqrt(math.pow(posX-rowX,2) + math.pow(posY-rowY,2))
                    distance = 1 + (distance * math.cos(raydir-playdir))
                    along = round(rowX)%WIDE
                    rays.append([rowX,rowY,distance,"row",along,hitX,hitY])
                    hitR = True

    hitC = False
    if (abs(slope) < 10000):
        for x in range(colRange[0],colRange[1],colRange[2]):
            if (hitC): break
            colX = (x * WIDE)
            colY = (slope * (colX - posX)) + posY
            if (colY > 0) and (colY < COLS*WIDE):
                hitY = math.floor(colY/WIDE)
                hitX = math.floor(colX/WIDE)+colHit
                if (int(gameboard[hitY][hitX]) == 1):
                    distance = math.sqrt(math.pow(posX-colX,2) + math.pow(posY-colY,2))
                    distance = 1 + (distance * math.cos(raydir-playdir))
                    along = round(colY)%WIDE
                    rays.append([colX,colY,distance,"col",along,hitX,hitY])
                    hitC = True

    if (len(rays) == 0):
        return False
    if (len(rays) == 1):
        return rays[0]
    else:
        if (rays[0][2] < rays[1][2]):
            return rays[0]
        else:
            return rays[1]

## #######################################################################################
## ################################## END : RAY-CASTING ##################################
## #######################################################################################
# プログラムを終了する
def terminate():
    pygame.quit()
    sys.exit()

# ------------------------------------------------
# (ROUTE)MAZE盤面を表示する
def route_display(field_data):

    # ---
    for line in field_data:
            print ("\t" + "%3s " * len(line) % tuple(line))

# ------------------------------------------------
# 盤面のCSVファイルを読み込み表示する
def read_boardfile(num_mzsize):
    # ------------------------------------------------
    # CSVファイルの読み込み
    code_csvout = "maze_board27.csv"       # file name
    file_readcsv = foldername + code_csvout   # standard(training) file name  
    df = pd.read_csv(file_readcsv)

    # ------------------------------------------------
    # 選択項目の読み込み(mx_mazeとmx_field)
    mx_maze     = df.loc[:, "0":"26"].values.tolist()   # 学習用（すべての情報を含む）
    mx_field    = mx_maze                               # ゲーム用（0と１のみ）

    # ------------------------------------------------
    # mx_maze : 学習用（すべての情報を含む）
    start_point, goal_point = [0, 0], [0, 0]
    for iRow in range(num_mzsize):
        for jCol in range(num_mzsize):
            if mx_maze[iRow][jCol] == "0":
                mx_maze[iRow][jCol] = 0
            if mx_maze[iRow][jCol] == "-1":
                mx_maze[iRow][jCol] = -1
            if mx_maze[iRow][jCol] == "-5":
                mx_maze[iRow][jCol] = -5
            if mx_maze[iRow][jCol] == "-10":
                mx_maze[iRow][jCol] = -10
            # -----
            if mx_maze[iRow][jCol] == "S":
                start_point = [iRow, jCol]
            if mx_maze[iRow][jCol] == 5000:
                goal_point = [iRow, jCol]
    #print("start_point:{0}, goal_point:{1}".format(start_point, goal_point))

    # ------------------------------------------------
    # mx_field : ゲーム用（0と１のみ）
    for iRow in range(num_mzsize):
        for jCol in range(num_mzsize):
            if mx_field[iRow][jCol] == "#":
                mx_maze[iRow][jCol] = 1
            else:
                mx_maze[iRow][jCol] = 0

    return mx_maze, start_point, goal_point, mx_field

    
# ----------------
class Game(object):

    def __init__(self, SCREEN):

        # -------------------------
        # 盤面データを読む
        self.mx_lm        = [[0, 2],[26, 25]]
        self.maze_field   = maze_field
        self.start_point  = start_point
        self.goal_point   = goal_point
        state_chess       = [0, 0]
        state             = [0, 0, 0, 0, 0, 0, 0]
        arr_RTDists       = [0, 0, 0, 0, 0]
        movables          = [[0, 0],[0, 0]]
        pos_MZstart       = self.mx_lm[0]

        # -------------------------
        # 2種類の「方向(MapとView)」
        self.MapPosition    = [0, 0]
        self.MapPosition[0] = round(2*WIDE+WIDE/2)
        self.MapPosition[1] = round(2*WIDE+WIDE/2)
        self.MapDirection  = math.pi/2   # コマを動かす方向(レンダリング用、Radian)
        self.ViewDirection = -math.pi/2   # コマから環境を見る方向(レンダリング用、Radian)
        self.MapAngle   = 0.0   # コマを動かす方向(表示用、Degree)
        self.ViewAngle  = 0.0   # コマから環境を見る方向(表示用、Degree)
        
        # -------------------------
        # メイズのXY座標
        self.MazeYpos, self.MazeXpos = 0, 0     # メイズのY座標, X座標

        # -------------------------
        # 記録用パラメタ類(ターンベース)
        self.arr_iturn    = []    # ターン・カウンタリスト
        self.arr_CSorders = []    # 指示リスト(アドレス)
        self.arr_acType   = []    # 指示のタイプ
        self.arr_scores   = []    # ゲームスコアリスト
        self.arr_dones    = []    # ゲームオーバーフラグ
        self.arr_predQV   = []    # Q値のリスト
        # -------------------------
        # 記録用パラメタ類(ターンベース)
        self.arr_Tdist    = []    # Total距離
        self.arr_sminRT   = []    # 空間minRT距離
        self.arr_tlminRT  = []    # タイムラインminRT距離
        self.arr_sminRTB  = []    # 空間用minRT距離(B)
        self.arr_sminRTC  = []    # 空間用minRT距離(C)

        # -------------------------
        # 共通変数
        self.SCREEN     = SCREEN
        self.BACKGROUND = makeBackground(ROWS,COLS)
        self.MAP        = makeMap(gameboard)
        self.MAPPOS     = pygame.Surface((COLS,ROWS))
        self.showMap    = False
        CRR_MPODR, LAST_MPODR   = 'DOWN', 'DOWN'

        # -------------------------
        # レンダリング初期化
        CLOCK.tick(20)
        font = pygame.font.Font(None, 55)               # フォントの設定(55px)
        self.SCREEN.fill((255,255,0))
        text1 = font.render("PUSH <DIRECTION> KEY", True, (255,0,255))   # 描画する文字列の設定
        self.SCREEN.blit(text1, [100, 200])# 文字列の表示位置
        text2 = font.render("THEN PUSH <m> KEY", True, (255,0,0))   # 描画する文字列の設定
        self.SCREEN.blit(text2, [130, 400])# 文字列の表示位置
        pygame.display.update()

        # -------------------------
        # ゲームのリセット
        iCnt_turn, done = 0, False
        # ゲームを実行する
        while True:

            # ------------------------------------------------
            # キーの種類(上下左右移動用)
            # keys[pygame.K_LEFT]  or keys[pygame.K_a] ->  LEFT コマを左移動
            # keys[pygame.K_RIGHT] or keys[pygame.K_d] ->  RIGHT　コマを右移動
            # keys[pygame.K_UP]    or keys[pygame.K_w] ->  UP　コマを上移動
            # keys[pygame.K_DOWN]  or keys[pygame.K_s] ->  DOWN　コマを下移動
            # event.type == pygame.QUIT ->  QUIT  閉じるボタンが押されたら終了
            # event.key == pygame.K_m ->  K_m　　mキー　地図と方向を表示する
            # ------------------------------------------------
            FLG_KEY, arr_CSorder  = "NA", []
            keys = pygame.key.get_pressed()
            # ------------------------------------------------
            # QUITとmキーを押した場合
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    terminate()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_m:
                        self.showMap = not self.showMap
            # ------------------------------------------------
            # コマ(Chess)を動かす
            if keys[pygame.K_LEFT] or keys[pygame.K_a]:
                # マップ(MP)コマンドを定義します
                CRR_MPODR  = "LEFT"
                # マップ(MP)の上下左右のコマンドをコマ(CS)の前進回転コマンドに変換します。
                arr_CSorder = self.translate_command(CRR_MPODR, LAST_MPODR)
                # キーがインプットされました
                #print("CRR_MPODR:{}, LAST_MPODR:{}".format(CRR_MPODR,LAST_MPODR))
                time.sleep(0.5)
                FLG_KEY    = "ON"
            # -----
            elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
                # マップ(MP)コマンドを定義します
                CRR_MPODR  = "RIGHT"
                # マップ(MP)の上下左右のコマンドをコマ(CS)の前進回転コマンドに変換します。
                arr_CSorder = self.translate_command(CRR_MPODR, LAST_MPODR)
                # キーがインプットされました
                #print("CRR_MPODR:{}, LAST_MPODR:{}".format(CRR_MPODR,LAST_MPODR))
                time.sleep(0.5)
                FLG_KEY    = "ON"
            # -----
            elif keys[pygame.K_UP] or keys[pygame.K_w]:
                # マップ(MP)コマンドを定義します
                CRR_MPODR  = "UP"
                # マップ(MP)の上下左右のコマンドをコマ(CS)の前進回転コマンドに変換します。
                arr_CSorder = self.translate_command(CRR_MPODR, LAST_MPODR)
                # キーがインプットされました
                #print("CRR_MPODR:{}, LAST_MPODR:{}".format(CRR_MPODR,LAST_MPODR))
                time.sleep(0.5)
                FLG_KEY    = "ON"
            # -----
            elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
                # マップ(MP)コマンドを定義します
                CRR_MPODR  = "DOWN"
                # マップ(MP)の上下左右のコマンドをコマ(CS)の前進回転コマンドに変換します。
                arr_CSorder = self.translate_command(CRR_MPODR, LAST_MPODR)
                # キーがインプットされました
                #print("CRR_MPODR:{}, LAST_MPODR:{}".format(CRR_MPODR,LAST_MPODR))
                time.sleep(0.5)
                FLG_KEY    = "ON"
            # -----
            if FLG_KEY == "ON" and len(arr_CSorder) > 0:
                # コマを回転と前進後退に翻訳して動かす
                for Chess_order in arr_CSorder:
                    state, arr_RTDists, movables = self.move_chess(Chess_order, iCnt_turn)
                # -----
                # pygameへの表示
                self.SCREEN.fill((0,0,0))
                self.SCREEN.blit(pygame.transform.scale(self.BACKGROUND,(RES*2,RES*2)),(0,0))
                # -----
                bar = 0
                for i in FOV:
                    rayDir = self.ViewDirection+i
                    if (rayDir < 0): rayDir += 2*math.pi
                    if (rayDir > 2*math.pi): rayDir -= 2*math.pi
                    myRay = castRay(rayDir,self.MapPosition[0],self.MapPosition[1],self.ViewDirection,gameboard)
                    if (myRay != False):
                        dist = myRay[2]
                        height  = round(PLAYERDISTANCE * HIGH/dist)
                        top     = round((640 - height)/2)
                        if (myRay[3] == "row"):
                            if ((myRay[5] == 1) and (myRay[6] == 0)):
                                self.SCREEN.blit(pygame.transform.scale(ROWBGN[myRay[4]],(2,height)), [bar,top, 2, height])
                            elif ((myRay[5] == (MAPSIZE*2)-1) and (myRay[6] == (MAPSIZE*2))):
                                self.SCREEN.blit(pygame.transform.scale(ROWEND[myRay[4]],(2,height)), [bar,top, 2, height])
                            else:
                                self.SCREEN.blit(pygame.transform.scale(ROWWLL[myRay[4]],(2,height)), [bar,top, 2, height])
                        # -----
                        else:
                            if ((myRay[5] == 0) and (myRay[6] == 1)):
                                self.SCREEN.blit(pygame.transform.scale(COLBGN[myRay[4]],(2,height)), [bar,top, 2, height])
                            elif ((myRay[5] == (MAPSIZE*2)) and (myRay[6] == (MAPSIZE*2)-1)):
                                self.SCREEN.blit(pygame.transform.scale(COLEND[myRay[4]],(2,height)), [bar,top, 2, height])
                            else:
                                self.SCREEN.blit(pygame.transform.scale(COLWLL[myRay[4]],(2,height)), [bar,top, 2, height])
                    bar += 2
                # -----
                if (self.showMap):
                    self.MAPPOS.blit(self.MAP,(0,0))
                    pygame.draw.rect(self.MAPPOS, (0,255,0), [math.floor(self.MapPosition[0]/WIDE),math.floor(self.MapPosition[1]/WIDE), 1, 1], 0)
                    self.SCREEN.blit(pygame.transform.scale(self.MAPPOS,(COLS*4,ROWS*4)),(0,0))
                    pygame.draw.circle(self.SCREEN, (0,0,0), [RES,20], 20, 1)
                    cenX = RES
                    cenY = 20
                    edgX = cenX + (18 * math.cos(self.ViewDirection))
                    edgY = cenY + (18 * math.sin(self.ViewDirection))
                    pygame.draw.line(self.SCREEN, (0,255,0), [cenX,cenY], [edgX,edgY], 1)
                # -----
                # レンダリング更新
                pygame.display.update()
                # -----
                # 状態表示
                print("iTurn:{}, CRR_MPODR:{}, LAST_MPODR:{}, arr_CSorder:{}".format(iCnt_turn, CRR_MPODR, LAST_MPODR, arr_CSorder))
                print("iTurn:{}, state:{}, MapPosition: [{},{}], MapAngle:{}, ViewAngle:{}".format(iCnt_turn, state, self.MapPosition[0], self.MapPosition[1], self.MapAngle, self.ViewAngle))
                # カウントアップ
                FLG_KEY     = "DONE"
                LAST_MPODR  = CRR_MPODR
                iCnt_turn   = iCnt_turn + 1
            # -----
            if state[0] >= 25 and state[1] >= 25:
                # ゴールに到達しました
                print("game over break")
                break


    # ------------------------------------------------
    # マップ(MP)の上下左右のコマンドをコマ(CS)の前進回転コマンドに変換します。
    def translate_command(self, CRR_MPODR, LAST_MPODR):

        # ----------------
        # TURN_R 右回転 + 前進
        # TURN_L 左回転 + 前進
        # FORWARD 前進
        # BACK 後退
        # ----------------
        # コマの移動命令群「arr_CSorder」を生成する
        arr_CSorder = []
        # ----------------
        # 前進をする場合
        if CRR_MPODR == LAST_MPODR:
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 後退をする場合
        if CRR_MPODR == 'DOWN' and LAST_MPODR == 'UP':
            arr_CSorder.append('BACK')
            return arr_CSorder
        elif CRR_MPODR == 'RIGHT' and LAST_MPODR == 'LEFT':
            arr_CSorder.append('BACK')
            return arr_CSorder
        elif CRR_MPODR == 'LEFT' and LAST_MPODR == 'RIGHT':
            arr_CSorder.append('BACK')
            return arr_CSorder
        elif CRR_MPODR == 'UP' and LAST_MPODR == 'DOWN':
            arr_CSorder.append('BACK')
            return arr_CSorder
        # ----------------
        # DIRECTION / ROW / COL / ANGLE
        # LEFT / 0 / -1 / 180
        # RIGHT / 0 / 1 / 0 or 360
        # UP / -1 / 0 / 270
        # DOWN / 1 / 0 / 90
        # ----------------
        # 右回り(CLOCKWISE)
        # ----------------
        # 右90度旋回をする場合（LAST:LEFT -> ）
        if LAST_MPODR == 'LEFT' and CRR_MPODR == 'UP':
            arr_CSorder.append('TURN_R90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 右90度旋回をする場合（LAST:RIGHT -> ）
        elif LAST_MPODR == 'RIGHT' and CRR_MPODR == 'DOWN':
            arr_CSorder.append('TURN_R90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 右90度旋回をする場合（LAST:UP -> ）
        elif LAST_MPODR == 'UP' and CRR_MPODR == 'RIGHT':
            arr_CSorder.append('TURN_R90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 右90度旋回をする場合（LAST:DOWN -> ）
        elif LAST_MPODR == 'DOWN' and CRR_MPODR == 'LEFT':
            arr_CSorder.append('TURN_R90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 左回り(COUNTERCLOCKWISE)
        # ----------------
        # 左90度旋回をする場合（LAST: -> CRR:LEFT）
        if CRR_MPODR == 'LEFT' and LAST_MPODR == 'UP':
            arr_CSorder.append('TURN_L90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 左90度旋回をする場合（LAST: -> CRR:RIGHT）
        elif CRR_MPODR == 'RIGHT' and LAST_MPODR == 'DOWN':
            arr_CSorder.append('TURN_L90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 左90度旋回をする場合（LAST: -> CRR:UP）
        elif CRR_MPODR == 'UP' and LAST_MPODR == 'RIGHT':
            arr_CSorder.append('TURN_L90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        # ----------------
        # 左90度旋回をする場合（LAST: -> CRR:DOWN）
        elif CRR_MPODR == 'DOWN' and LAST_MPODR == 'LEFT':
            arr_CSorder.append('TURN_L90')
            arr_CSorder.append('FORWARD')
            return arr_CSorder
        
    # ------------------------------------------------
    # コマを動かす
    def move_chess(self, Chess_order, iCnt_turn):

        # ----------
        #time.sleep(0.05)
        state       = [-99.0]*7
        arr_RTDists = [-99.0]*5
        movables    = [[-99, -99],[-99, -99]]
        
        # ----------
        # 命令の種類(回転と前進後退用)
        # TURN_R 右回転
        # TURN_L 左回転
        # BACK 後退
        # FORWARD 前進
        # ----------
        if Chess_order == "TURN_L90": 
            #print("Chess_order: {0}".format(Chess_order))
            # コマの移動角度の計算をする
            self.MapDirection -= TURN*2
            if (self.MapDirection < 0): self.MapDirection += 2*math.pi
            self.MapAngle = round(self.MapDirection/math.pi/2*360, 0)
            return state, arr_RTDists, movables
        # -----
        elif Chess_order == "TURN_R90": 
            #print("Chess_order:{0}".format(Chess_order))
            # コマの移動角度の計算をする
            self.MapDirection += TURN*2
            if (self.MapDirection > 2*math.pi): self.MapDirection -= 2*math.pi
            self.MapAngle = round(self.MapDirection/math.pi/2*360, 0)
            return state, arr_RTDists, movables
        # -----
        elif Chess_order == "FORWARD": 
            #print("Chess_order: {0}".format(Chess_order))
            # コマを移動する
            tmpX = self.MapPosition[0] + (STEP * math.cos(self.MapDirection))
            tmpY = self.MapPosition[1] + (STEP * math.sin(self.MapDirection))
            if (canGo(tmpX,tmpY,gameboard)):
                self.MapPosition[0] = tmpX
                self.MapPosition[1] = tmpY
            # -------------------------
            # メイズのXY座標
            self.MazeYpos = math.floor(self.MapPosition[1]/WIDE)   # メイズのY座標
            self.MazeXpos = math.floor(self.MapPosition[0]/WIDE)   # メイズのX座標
            # -------------------------
            # カメラのVIEW角度計算をする
            state_chess = [self.MazeYpos, self.MazeXpos]
            state, arr_RTDists, movables = self.calc_angle(iCnt_turn, state_chess)
            return state, arr_RTDists, movables
        # -----
        elif Chess_order == "BACK":  
            #print("Chess_order: {0}".format(Chess_order))
            # コマを移動する
            tmpX = self.MapPosition[0] - (STEP * math.cos(self.MapDirection))
            tmpY = self.MapPosition[1] - (STEP * math.sin(self.MapDirection))
            if (canGo(tmpX,tmpY,gameboard)):
                self.MapPosition[0] = tmpX
                self.MapPosition[1] = tmpY
            # -------------------------
            # メイズのXY座標
            self.MazeYpos = math.floor(self.MapPosition[1]/WIDE)   # メイズのY座標
            self.MazeXpos = math.floor(self.MapPosition[0]/WIDE)   # メイズのX座標
            # -------------------------
            # カメラのVIEW角度計算をする
            state_chess = [self.MazeYpos, self.MazeXpos]
            state, arr_RTDists, movables = self.calc_angle(iCnt_turn, state_chess)
            return state, arr_RTDists, movables

    # ------------------------------------------------
    # カメラの角度計算をする
    def calc_angle(self, iCnt_turn, state_chess):

        # ----------------
        # 状態(STATE)を生成する
        state, arr_RTDists = calc_address(self.MazeYpos, self.MazeXpos, self.mx_lm, iCnt_turn) 
        movables = maze_field.get_actions(state_chess)
        # ----------------
        # 次の行動(ACTION)を発行する
        acType, action_chess, Qvalue = dql_solver.choose_action(state, movables)
        _, reward, done, num_bump = maze_field.get_val(action_chess, state_chess, movables)
        
        # ----------------
        # 次の行動(ACTION-８方向)に進む
        # action number / row / col / 方向/ ベクトル
        # 0 / -1 / 0  / 上上(up-up) / [-1, 0]
        # 1 / -1 / -1  / 上左(up-left) / [-1, -1]
        # 2 / 0 / -1  / 左左(left-left) / [0, -1]
        # 3 / +1 / -1  / 左下(down-left) / [+1, -1]
        # 4 / +1 / 0  / 下下(down-down) / [+1, 0]
        # 5 / +1 / +1  / 下右(down-right) / [+1, +1]
        # 6 / 0  / +1 / 右右(right-right) / [0, +1]
        # 7 / -1  / +1 / 上右(up-right) / [-1, +1]
        # ----------------
        # DIRECTION / ROW / COL / ANGLE
        # LEFT / 0 / -1 / 180
        # RIGHT / 0 / 1 / 0 or 360
        # UP / -1 / 0 / 270 or -90
        # DOWN / 1 / 0 / 90
        # ----------------
        # 変則ONE-HOT化
        diff_row = action_chess[0] - state_chess[0]
        diff_col = action_chess[1] - state_chess[1]
        # ----------------
        # 0 / -1 / 0  / 上上(up-up) / [-1, 0]
        if diff_row < 0 and int(diff_col) == 0:
            self.ViewAngle = 270      # UP / -1 / 0 / 270 or -90
        # 1 / -1 / -1  / 上左(up-left) / [-1, -1]
        elif diff_row < 0 and diff_col < 0:
            self.ViewAngle = ( 270 + 180 ) * 0.5      # UP / -1 / 0 / 270 or -90, # LEFT / 0 / -1 / 180
        # 2 / 0 / -1  / 左左(left-left) / [0, -1]
        elif int(diff_row) == 0 and diff_col < 0:
            self.ViewAngle = 180       # LEFT / 0 / -1 / 180
        # 3 / +1 / -1  / 左下(down-left) / [+1, -1]
        elif diff_row > 0 and diff_col < 0:
            self.ViewAngle = ( 90 + 180 ) * 0.5      # LEFT / 0 / -1 / 180  # DOWN / 1 / 0 / 90
        # 4 / +1 / 0  / 下下(down-down) / [+1, 0]
        elif diff_row > 0 and int(diff_col) == 0:
            self.ViewAngle = 90        # DOWN / 1 / 0 / 90
        # 5 / +1 / +1  / 下右(down-right) / [+1, +1]
        elif diff_row > 0 and diff_col > 0:
            self.ViewAngle = ( 0 + 90 ) * 0.5     # DOWN / 1 / 0 / 90  # RIGHT / 0 / 1 / 0 or 360
        # 6 / 0  / +1 / 右右(right-right) / [0, +1]
        elif int(diff_row) == 0 and diff_col > 0:
            self.ViewAngle = 360    # RIGHT / 0 / 1 / 0 or 360
        # 7 / -1  / +1 / 上右(up-right) / [-1, +1]
        elif diff_row < 0 and diff_col > 0:
            self.ViewAngle = ( -90 + 0 ) * 0.5      # UP / -1 / 0 / 270 or -90  # RIGHT / 0 / 1 / 0 or 360
        # ----------------
        # self.ViewDirectionに変換する
        self.ViewDirection = 2*math.pi*self.ViewAngle/360
        #print("iTurn:{}, ViewAngle:{}, action_chess:{}, state_chess:{}, movables:{}, done:{}".format(iCnt_turn, self.ViewAngle, action_chess, state_chess, movables, done))
        # ----------------
        T_Dist        = arr_RTDists[0]    # Total距離
        dist_sminRT   = arr_RTDists[1]    # 空間minRT距離
        dist_tlminRT  = arr_RTDists[2]    # タイムラインminRT距離
        dist_sminRTB  = arr_RTDists[3]    # 空間用minRT距離(B)
        dist_sminRTC  = arr_RTDists[4]    # 空間用minRT距離(C)
        # -------------------------
        # 記録用リストを追記する
        self.arr_iturn.append(iCnt_turn)    # ターン・カウンタリスト
        self.arr_CSorders.append(action_chess)      # 指示リスト(アドレス)
        self.arr_acType.append(acType)      # 指示のタイプ
        self.arr_predQV.append(Qvalue)      # Q値のリスト
        # -------------------------
        # 記録用パラメタ類(ターンベース)
        self.arr_Tdist.append(T_Dist-15.0)       # Total距離
        self.arr_sminRT.append(dist_sminRT)     # 空間minRT距離
        self.arr_tlminRT.append(dist_tlminRT)    # タイムラインminRT距離
        self.arr_sminRTB.append(dist_sminRTB)    # 空間用minRT距離(B)
        self.arr_sminRTC.append(dist_sminRTC)    # 空間用minRT距離(C)

        return state, arr_RTDists, movables

# ------------------------------------------------
# メイン関数
if __name__ == '__main__':

    # ------------------------------------------------
    # ORIGINAL-MAZE盤面を表示する
    MAPSIZE = 13    # ゲーム盤SIZEが27の場合にはMAPSIZE13になります
    maze = makeMaze(MAPSIZE,MAPSIZE)
    gameboard = gameBoard(maze)
    #print("--- gameboard ---")
    #print(gameboard)

    # ------------------------------------------------
    # 盤面のCSVファイルを読み込み表示する
    # mx_maze  : 学習用（すべての情報を含む）
    # mx_field : ゲーム用（0と１のみ）
    num_mzsize = MAPSIZE*2 + 1    # ゲーム盤SIZEが27の場合にはMAPSIZE13になります
    mx_maze, start_point, goal_point, mx_field = read_boardfile(num_mzsize)
    gameboard = mx_field

    # ------------------------------------------------
    # (ROUTE)MAZE盤面を表示する
    route_display(gameboard)

    # ------------------------------------------------
    # MAZEの実行
    COLS    = len(gameboard)
    ROWS    = len(gameboard[0])
    SCREEN  = pygame.display.set_mode((RES*2,RES*2))

    # ------------------------------------------------
    # ゲームの実行
    Game(SCREEN)

```

QEU:FOUNDER ; “最適ルートを歩くと、**「なるほど・・・」と思える視角を提供してくれます**ね。”

![imageRL6-3-2](https://reinforce.github.io/images/imageRL6-3-2.jpg) 

D先生 : “うまく目線を決めてくれるのであれば、AGV用にラインを引く必要がないですね。”

![imageRL6-3-3](https://reinforce.github.io/images/imageRL6-3-3.jpg) 

QEU:FOUNDER ; “そう・・・、それが今回のポイントの一つです。ラインを引いてAGVを走らせるのはとても簡単です。ライン無しでAGVが動くのであれば、AGVはさらに「何ができる」のか・・・。”

D先生 : “そこまで先のことはともかく・・・。他の場所ではカメラ視点はどうなるんですか？”

QEU:FOUNDER ; “じゃあ、他の場所を見てみましょう・・・。”

![imageRL6-3-4](https://reinforce.github.io/images/imageRL6-3-4.jpg) 

QEU:FOUNDER ; “ついでにもう一つ・・・。どうですか？”

![imageRL6-3-5](https://reinforce.github.io/images/imageRL6-3-5.jpg) 

D部長: “つまり、**なんらかの「イレギュラー」があったとき**にも、荷物をうまく届けてくれるでしょう。”

QEU:FOUNDER ; “今回はここまで・・・。”


## ～ まとめ ～
 
QEU:FOUNDER ： “なんか、いろいろな意味で**「壊れてきている」**よね・・・。ある意味で、いいことでもあるけどさ・・・。”

 <iframe width="560" height="315" src="https://www.youtube.com/embed/5DnqKyvsOR0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

D先生 : “**「有効期限切れのモノを無理やり引っ張ってきた反動」**が来ているんだよね。平成（時代）というシロモノが、総じて**「（昭和で）有効切れのモノを上から押し売りしてきた」時代**でもあるし・・・。結局、作られた原理の本質が「上が下からカネを吸い上げたい」ものでしかなかったことが見えてきました。”
 
![imageRL6-3-6](https://reinforce.github.io/images/imageRL6-3-6.jpg) 

QEU:FOUNDER ： “おいおい・・・、D先生・・・。これは、いくらなんでも違うでしょう・・・。確かに、リスクに弱い手法であることは間違いないが・・・。ケイレツとはよく言ったもので、この手法は縁遠いサプライアに対して押し付けるものではないが、**ちゃんと上が下の世話をしているサプライチェーンに提供するのであれば素晴らしい手法**だと思いますよ。”
 
C部長: “ボクは毎日、貴い原理を拝んでおります。”


